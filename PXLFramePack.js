class PXLFramePack
{
	// Параметры, определяемые конструктором
	#params = 
	{
		width: 0,			// Ширина экрана, пикселей
		height: 0,			// Высота экрана, пикселей
		pixel: 0,			// Формат пикселей
		strip: 0,			// Формат ленты
	};
	
	
	constructor(params)
	{
		this.#params = Object.assign({}, this.#params, params);
		
		return;
	}
	
	// Возвращает максимально-возмжный размер кадра, включая заголовок, байт
	GetMaxFrameSize()
	{
		return ((this.#params.width * this.#params.height) * 2) + 4;
	}
	
	// Возвращает байт настроек для заголовка фала
	GetPixelStripByte()
	{
		return (this.#params.pixel << 4) | this.#params.strip;
	}
	
	/*
		pixels - Массив исходных пикселей
		timeout - Задержка отображения кадра
		buffer - Буффер для вставки сжатых данных
		buffer_idx -  Индекс начала данных для вставки
		return - Новый buffer_idx, указывающий на следующий свободный элемент массива
	*/
	Run(pixels, timeout, buffer, buffer_idx)
	{
		let data = 0;
		
		switch(this.#params.pixel)
		{
			case 14: { data = this.#pack14(pixels, timeout, buffer, buffer_idx); break; }
			default: { console.log('No pixel format!'); break; }
		}
		
		return data;
	}
	
	
	#pack14(pixels, timeout, buffer, buffer_idx)
	{
		const rgb888to555 = 
		[
			0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 
			0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 
			0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 
			0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08, 
			0x08, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0A, 0x0A, 0x0A, 0x0A, 
			0x0A, 0x0A, 0x0A, 0x0A, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 
			0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0E, 0x0E, 0x0E, 0x0E, 
			0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x10, 0x10, 0x10, 0x10, 
			0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x12, 0x12, 0x12, 0x12, 
			0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14, 0x14, 
			0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16, 0x16, 
			0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18, 0x18, 
			0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x1A, 0x1A, 0x1A, 0x1A, 
			0x1A, 0x1A, 0x1A, 0x1A, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 
			0x1C, 0x1C, 0x1C, 0x1C, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1D, 0x1E, 0x1E, 0x1E, 0x1E, 
			0x1E, 0x1E, 0x1E, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 
		];
		
		// Сохраняем timeout в заголовке кадра
		buffer[buffer_idx++] = (timeout >> 0) & 0xFF;
		buffer[buffer_idx++] = (timeout >> 8) & 0xFF;
		
		// Отметка адреса, куда нужно вставить кол-во пикселей в кадре.
		let pixel_count_index = buffer_idx;
		buffer_idx += 2;
		
		let pixel_count = 0;
		
		// Для алгоритма поиска одинаковых пикселей между предыдущим и текущим пикселем
		let last_pixel_color = [];
		let last_pixel_idx = -1;
		
		// Объект пикселя, чтобы не менять оригинальный буффер
		let pixel = null;
		
		for(let i = 0; i < pixels.length; i += 3)
		{
			pixel = { idx: (i / 3), color: [pixels[i + 0], pixels[i + 1], pixels[i + 2], 0xFF] };

/*
			// Алгоритм пропуска пустых пикселей
			let pixel_delta_last_to_current = (last_pixel_idx === -1) 
				? pixel.idx
				: pixel.idx - last_pixel_idx - 1;
			
			// Заполняем пустые пиксели
			while(pixel_delta_last_to_current > 0)
			{
				let skip = Math.min(64, pixel_delta_last_to_current);
				
				buffer[buffer_idx++] = (0x80 | (skip - 1));
				
				pixel_delta_last_to_current -= skip;
				pixel_count++;
			}
*/

			// Вставляем несжатый пиксель RGB555
			{
				let color555 = 0x0000;
				
				color555 |= rgb888to555[pixel.color[0]] << 10;
				color555 |= rgb888to555[pixel.color[1]] << 5;
				color555 |= rgb888to555[pixel.color[2]] << 0;
				
				buffer[buffer_idx++] = (color555 >> 8) & 0xFF;
				buffer[buffer_idx++] = (color555 >> 0) & 0xFF;
				
				last_pixel_idx = pixel.idx;
				pixel_count++;
			}
		};
		
		buffer[pixel_count_index++] = (pixel_count >> 0) & 0xFF;
		buffer[pixel_count_index++] = (pixel_count >> 8) & 0xFF;
		
		return buffer_idx;
	}
};

module.exports = { PXLFramePack };
